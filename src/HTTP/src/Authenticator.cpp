// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include "Sourcey/HTTP/Authenticator.h"
#include "Sourcey/HTTP/Request.h"
#include "Sourcey/HTTP/Response.h"

#include "Poco/Base64Encoder.h"
#include "Poco/Base64Decoder.h"


namespace scy {
namespace http {


/*
Authenticator::Authenticator()
{
}


Authenticator::Authenticator(const std::string& username, const std::string& password):
	_digest(username, password)
{
}


Authenticator::~Authenticator()
{
}


void Authenticator::fromUserInfo(const std::string& userInfo)
{
	std::string username;
	std::string password;

	extractCredentials(userInfo, username, password);
	setUsername(username);
	setPassword(password);
	/// TODO: Reset digest state?
}


void Authenticator::fromURI(const http::URL& uri)
{
	std::string username;
	std::string password;

	extractCredentials(uri, username, password);
	setUsername(username);
	setPassword(password);
	/// TODO: Reset digest state?
}


void Authenticator::authenticate(http::Request& request, const http::Response& response)
{
	for (http::Response::ConstIterator iter = response.find("WWW-Authenticate"); iter != response.end(); ++iter)
	{
		if (isBasicCredentials(iter->second)) 
		{
			BasicAuthenticator(_digest.getUsername(), _digest.getPassword()).authenticate(request);
			return;
		} 
		else if (isDigestCredentials(iter->second)) 
		{
			_digest.authenticate(request, HTTPAuthenticationParams(iter->second.substr(7)));
			return;
		}
	}
}


void Authenticator::updateAuthInfo(http::Request& request)
{
	if (request.has(http::Request::AUTHORIZATION)) 
	{
		const std::string& authorization = request.get(http::Request::AUTHORIZATION);

		if (isBasicCredentials(authorization)) 
		{
			BasicAuthenticator(_digest.getUsername(), _digest.getPassword()).authenticate(request);
		} 
		else if (isDigestCredentials(authorization)) 
		{
			_digest.updateAuthInfo(request);
		}
	}
}


void Authenticator::proxyAuthenticate(http::Request& request, const http::Response& response)
{
	for (http::Response::ConstIterator iter = response.find("Proxy-Authenticate"); iter != response.end(); ++iter)
	{
		if (isBasicCredentials(iter->second)) 
		{
			BasicAuthenticator(_digest.getUsername(), _digest.getPassword()).proxyAuthenticate(request);
			return;
		} 
		else if (isDigestCredentials(iter->second)) 
		{
			_digest.proxyAuthenticate(request, HTTPAuthenticationParams(iter->second.substr(7)));
			return;
		}
	}
}


void Authenticator::updateProxyAuthInfo(http::Request& request)
{
	if (request.has(http::Request::PROXY_AUTHORIZATION)) 
	{
		const std::string& authorization = request.get(http::Request::PROXY_AUTHORIZATION);

		if (isBasicCredentials(authorization)) 
		{
			BasicAuthenticator(_digest.getUsername(), _digest.getPassword()).proxyAuthenticate(request);
		} 
		else if (isDigestCredentials(authorization)) 
		{
			_digest.updateProxyAuthInfo(request);
		}
	}
}


bool Authenticator::isBasicCredentials(const std::string& header)
{
	return util::icompare(header, 0, 5, "Basic") == 0 && (header.size() > 5 ? Poco::Ascii::isSpace(header[5]) : true);
}


bool Authenticator::isDigestCredentials(const std::string& header)
{
	return util::icompare(header, 0, 6, "Digest") == 0 && (header.size() > 6 ? Poco::Ascii::isSpace(header[6]) : true);
}


bool Authenticator::hasBasicCredentials(const http::Request& request)
{
	return request.has(http::Request::AUTHORIZATION) && isBasicCredentials(request.get(http::Request::AUTHORIZATION));
}


bool Authenticator::hasDigestCredentials(const http::Request& request)
{
	return request.has(http::Request::AUTHORIZATION) && isDigestCredentials(request.get(http::Request::AUTHORIZATION));
}


bool Authenticator::hasProxyBasicCredentials(const http::Request& request)
{
	return request.has(http::Request::PROXY_AUTHORIZATION) && isBasicCredentials(request.get(http::Request::PROXY_AUTHORIZATION));
}


bool Authenticator::hasProxyDigestCredentials(const http::Request& request)
{
	return request.has(http::Request::PROXY_AUTHORIZATION) && isDigestCredentials(request.get(http::Request::PROXY_AUTHORIZATION));
}


void Authenticator::extractCredentials(const std::string& userInfo, std::string& username, std::string& password)
{
	const std::string::size_type p = userInfo.find(':');

	if (p != std::string::npos) 
	{
		username.assign(userInfo, 0, p);
		password.assign(userInfo, p + 1, std::string::npos);
	} 
	else 
	{
		username.assign(userInfo);
		password.clear();
	}
}


void Authenticator::extractCredentials(const http::URL& uri, std::string& username, std::string& password)
{
	if (!uri.getUserInfo().empty()) 
	{
		extractCredentials(uri.getUserInfo(), username, password);
	}
}
*/



// -------------------------------------------------------------------
//

const std::string BasicAuthenticator::SCHEME = "Basic";


BasicAuthenticator::BasicAuthenticator()
{
}

	
BasicAuthenticator::BasicAuthenticator(const std::string& username, const std::string& password):
	_username(username),
	_password(password)
{
}


BasicAuthenticator::BasicAuthenticator(const http::Request& request)
{
	std::string scheme;
	std::string authInfo;
	request.getCredentials(scheme, authInfo);
	if (util::icompare(scheme, SCHEME) == 0)
	{
		parseAuthInfo(authInfo);
	}
	else throw Exception("Basic authentication expected");
}


BasicAuthenticator::BasicAuthenticator(const std::string& authInfo)
{
	parseAuthInfo(authInfo);
}


BasicAuthenticator::~BasicAuthenticator()
{
}


void BasicAuthenticator::setUsername(const std::string& username)
{
	_username = username;
}
	
	
void BasicAuthenticator::setPassword(const std::string& password)
{
	_password = password;
}
	
	
void BasicAuthenticator::authenticate(http::Request& request) const
{
	std::ostringstream ostr;
	Poco::Base64Encoder encoder(ostr);
	encoder.rdbuf()->setLineLength(0);
	encoder << _username << ":" << _password;
	encoder.close();
	request.setCredentials(SCHEME, ostr.str());
}


void BasicAuthenticator::proxyAuthenticate(http::Request& request) const
{
	std::ostringstream ostr;
	Poco::Base64Encoder encoder(ostr);
	encoder.rdbuf()->setLineLength(0);
	encoder << _username << ":" << _password;
	encoder.close();
	request.setProxyCredentials(SCHEME, ostr.str());
}


void BasicAuthenticator::parseAuthInfo(const std::string& authInfo)
{
	static const int eof = std::char_traits<char>::eof();

	std::istringstream istr(authInfo);
	Poco::Base64Decoder decoder(istr);
	int ch = decoder.get();
	while (ch != eof && ch != ':')
	{
		_username += (char) ch;
		ch = decoder.get();
	}
	if (ch == ':') ch = decoder.get();
	while (ch != eof)
	{
		_password += (char) ch;
		ch = decoder.get();
	}
}


// -------------------------------------------------------------------
//


/*
const std::string HTTPDigestCredentials::SCHEME = "Digest";
const std::string HTTPDigestCredentials::DEFAULT_ALGORITHM("MD5");
const std::string HTTPDigestCredentials::DEFAULT_QOP("");
const std::string HTTPDigestCredentials::NONCE_PARAM("nonce");
const std::string HTTPDigestCredentials::REALM_PARAM("realm");
const std::string HTTPDigestCredentials::QOP_PARAM("qop");
const std::string HTTPDigestCredentials::ALGORITHM_PARAM("algorithm");
const std::string HTTPDigestCredentials::USERNAME_PARAM("username");
const std::string HTTPDigestCredentials::OPAQUE_PARAM("opaque");
const std::string HTTPDigestCredentials::URI_PARAM("uri");
const std::string HTTPDigestCredentials::RESPONSE_PARAM("response");
const std::string HTTPDigestCredentials::AUTH_PARAM("auth");
const std::string HTTPDigestCredentials::CNONCE_PARAM("cnonce");
const std::string HTTPDigestCredentials::NC_PARAM("nc");
int HTTPDigestCredentials::_nonceCounter(0);
Mutex HTTPDigestCredentials::_nonceMutex;


HTTPDigestCredentials::HTTPDigestCredentials()
{
}

	
HTTPDigestCredentials::HTTPDigestCredentials(const std::string& username, const std::string& password):
	_username(username),
	_password(password)
{
}


HTTPDigestCredentials::~HTTPDigestCredentials()
{
}


void HTTPDigestCredentials::setUsername(const std::string& username)
{
	_username = username;
}
	

void HTTPDigestCredentials::setPassword(const std::string& password)
{
	_password = password;
}


void HTTPDigestCredentials::authenticate(http::Request& request, const http::Response& response)
{
	authenticate(request, HTTPAuthenticationParams(response));
}


void HTTPDigestCredentials::authenticate(http::Request& request, const HTTPAuthenticationParams& responseAuthParams)
{
	createAuthParams(request, responseAuthParams);
	request.setCredentials(SCHEME, _requestAuthParams.toString());
}


void HTTPDigestCredentials::updateAuthInfo(http::Request& request)
{
	updateAuthParams(request);
	request.setCredentials(SCHEME, _requestAuthParams.toString());
}


void HTTPDigestCredentials::proxyAuthenticate(http::Request& request, const http::Response& response)
{
	proxyAuthenticate(request, HTTPAuthenticationParams(response));
}


void HTTPDigestCredentials::proxyAuthenticate(http::Request& request, const HTTPAuthenticationParams& responseAuthParams)
{
	createAuthParams(request, responseAuthParams);
	request.setProxyCredentials(SCHEME, _requestAuthParams.toString());
}


void HTTPDigestCredentials::updateProxyAuthInfo(http::Request& request)
{
	updateAuthParams(request);
	request.setProxyCredentials(SCHEME, _requestAuthParams.toString());
}


std::string HTTPDigestCredentials::createNonce()
{
	Mutex::ScopedLock lock(_nonceMutex);

	MD5Engine md5;
	Timestamp::TimeVal now = Timestamp().epochMicroseconds();

	md5.update(&_nonceCounter, sizeof(_nonceCounter));
	md5.update(&now, sizeof(now));

	++_nonceCounter;

	return DigestEngine::digestToHex(md5.digest());
}


void HTTPDigestCredentials::createAuthParams(const http::Request& request, const HTTPAuthenticationParams& responseAuthParams)
{
	/// Not implemented: "domain" auth parameter and integrity protection.

	if (!responseAuthParams.has(NONCE_PARAM) || !responseAuthParams.has(REALM_PARAM))
		throw ArgumentException("Invalid HTTP authentication parameters");

	const std::string& algorithm = responseAuthParams.get(ALGORITHM_PARAM, DEFAULT_ALGORITHM);

	if (icompare(algorithm, DEFAULT_ALGORITHM) != 0) 
		throw NotImplementedException("Unsupported digest algorithm", algorithm);

	const std::string& nonce = responseAuthParams.get(NONCE_PARAM);
	const std::string& qop = responseAuthParams.get(QOP_PARAM, DEFAULT_QOP);
	const std::string& realm = responseAuthParams.getRealm();

	_requestAuthParams.clear();
	_requestAuthParams.set(USERNAME_PARAM, _username);
	_requestAuthParams.set(NONCE_PARAM, nonce);
	_requestAuthParams.setRealm(realm);
	if (responseAuthParams.has(OPAQUE_PARAM)) 
	{
		_requestAuthParams.set(OPAQUE_PARAM, responseAuthParams.get(OPAQUE_PARAM));
	}

	if (qop.empty())
	{
		updateAuthParams(request);
	} 
	else
	{
		Poco::StringTokenizer tok(qop, ",", Poco::StringTokenizer::TOK_TRIM);
		bool qopSupported = false;
		for (Poco::StringTokenizer::Iterator it = tok.begin(); it != tok.end(); ++it)
		{
			if (icompare(*it, AUTH_PARAM) == 0)
			{
				qopSupported = true;
				_requestAuthParams.set(CNONCE_PARAM, createNonce());
				_requestAuthParams.set(QOP_PARAM, *it);
				updateAuthParams(request);
				break;
			}
		}
		if (!qopSupported) 
			throw NotImplementedException("Unsupported QoP requested", qop);
	} 
}


void HTTPDigestCredentials::updateAuthParams(const http::Request& request)
{
	MD5Engine engine;
	const std::string& qop = _requestAuthParams.get(QOP_PARAM, DEFAULT_QOP);
	const std::string& realm = _requestAuthParams.getRealm();
	const std::string& nonce = _requestAuthParams.get(NONCE_PARAM);

	_requestAuthParams.set(URI_PARAM, request.getURI());

	if (qop.empty())
	{
		const std::string ha1 = digest(engine, _username, realm, _password);
		const std::string ha2 = digest(engine, request.getMethod(), request.getURI());

		_requestAuthParams.set(RESPONSE_PARAM, digest(engine, ha1, nonce, ha2));
	}
	else if (icompare(qop, AUTH_PARAM) == 0) 
	{
		const std::string& cnonce = _requestAuthParams.get(CNONCE_PARAM);

		const std::string ha1 = digest(engine, _username, realm, _password);
		const std::string ha2 = digest(engine, request.getMethod(), request.getURI());
		const std::string nc = formatNonceCounter(updateNonceCounter(nonce));

		_requestAuthParams.set(NC_PARAM, nc);
		_requestAuthParams.set(RESPONSE_PARAM, digest(engine, ha1, nonce, nc, cnonce, qop, ha2));
	}
}


bool HTTPDigestCredentials::verifyAuthInfo(const http::Request& request) const
{
	HTTPAuthenticationParams params(request);
	return verifyAuthParams(request, params);
}


bool HTTPDigestCredentials::verifyAuthParams(const http::Request& request, const HTTPAuthenticationParams& params) const
{
	const std::string& nonce = params.get(NONCE_PARAM);
	const std::string& realm = params.getRealm();
	const std::string& qop   = params.get(QOP_PARAM, DEFAULT_QOP);
	std::string response;
	MD5Engine engine;
	if (qop.empty())
	{
		const std::string ha1 = digest(engine, _username, realm, _password);
		const std::string ha2 = digest(engine, request.getMethod(), request.getURI());
		response = digest(engine, ha1, nonce, ha2);
	}
	else if (icompare(qop, AUTH_PARAM) == 0) 
	{
		const std::string& cnonce = params.get(CNONCE_PARAM);
		const std::string& nc = params.get(NC_PARAM);
		const std::string ha1 = digest(engine, _username, realm, _password);
		const std::string ha2 = digest(engine, request.getMethod(), request.getURI());
		response = digest(engine, ha1, nonce, nc, cnonce, qop, ha2);
	}
	return response == params.get(RESPONSE_PARAM);
}


int HTTPDigestCredentials::updateNonceCounter(const std::string& nonce)
{
	NonceCounterMap::iterator iter = _nc.find(nonce);

	if (iter == _nc.end()) 
	{
		iter = _nc.insert(NonceCounterMap::value_type(nonce, 0)).first;
	}
	iter->second++;

	return iter->second;
}
*/


} } // namespace scy::http